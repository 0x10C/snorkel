<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Alex Ratner, Stephen Bach, Chris Ré" />
  <title>Programming Training Data: The New Interface Layer for ML</title>
  <link rel="stylesheet" href="blog.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Programming Training Data: The New Interface Layer for ML</h1>
Alex Ratner, Stephen Bach, Chris Ré<br />
<em>And referencing work by many other members of Hazy Research</em><br />
<a href="http://snorkel.stanford.edu">Back to the Snorkel Blog</a>
</div>

<p>Machine learning today is both far more and far less accessible than ever before. On the one hand, without any manual feature engineering or custom algorithm development, a developer can have a deep learning model downloaded and running near state-of-the-art within minutes. However, in other ways, machine learning has never been so opaque and inaccessible. Modern deep learning models admit one primary input type&#8212;training data&#8212;and other than that, are largely black boxes. Given some knowledge of a new domain or task, how do we inject this into our model? Given some modification to our objectives, how do we quickly modify our model? How does one <i>program</i> the modern machine learning stack?</p>

<p>One answer, of course, is that today’s ML systems don’t need to be programmed at all&#8212;and, given large volumes of training data, this is more true than ever before. However, in practice, these training sets have to be assembled, cleaned, and debugged&#8212;a prohibitively expensive and slow task, especially when domain expertise is required. Even more importantly, in the real world, tasks iteratively change and evolve. For example, labeling guidelines, granularities, or downstream use cases often change, necessitating re-labeling. For all these reasons, practitioners have increasingly been turning to <a href="https://hazyresearch.github.io/snorkel/blog/ws_blog_post.html">weaker forms of supervision</a>, such as heuristically generating training data with external knowledge bases, patterns or rules, or other classifiers. Essentially, these are all ways of programmatically generating training data&#8212;or, more succinctly, <i>programming training data</i>.</p>

<h2 id="code-as-supervision">Code as Supervision: Training ML by Programming</h2>

<p>Our system, Snorkel&#8212;which we report on in <b>a new VLDB 2018 paper posted <a href="https://arxiv.org/abs/1711.10160">here</a></b>&#8212;is one attempt to build a system around this new type of interaction with ML. In <a href="http://snorkel.stanford.edu/">Snorkel</a>, we use <b>no hand-labeled training data</b>, but instead ask users to write <i>labeling functions (LFs)</i>, bits of black-box code which label subsets of unlabeled data. For example, suppose we were trying to train a machine learning model to <a href="https://github.com/HazyResearch/snorkel/tree/master/tutorials/cdr">extract mentions of adverse drug reactions</a> from the scientific literature. To encode a heuristic about negation, for example, we could try writing the LF below:</p>

<div class="figure">
<img src="snorkel_img/snorkel_lf.png" width="50%" class="centered" alt="Example LF in Snorkel"/>
</div>

<p>We could then use a set of LFs to label training data for our machine learning model. Since labeling functions are just arbitrary bits of code, they can encode arbitrary signals: patterns, heuristics, external data resources, noisy labels from crowd workers, weak classifiers, and more. And, <b>as code</b>, we can reap all the other associated benefits like modularity, reusability, debuggability. If our modeling goals change, for example, we can just tweak our labeling functions to quickly adapt!</p>

<div class="figure">
<img src="snorkel_img/dp.png" width="100%" class="centered" alt="The data programming pipeline in Snorkel"/>
</div>

<p>The problem, of course, is that the labeling functions will produce noisy outputs which may overlap and conflict, producing less-than-ideal training labels. In Snorkel, we de-noise these labels using our <i><a href="https://arxiv.org/abs/1605.07723">data programming</a></i> approach, which comprises three steps:</p>
<ul>
	<li>First, we apply the labeling functions to unlabeled data.</li>

	<li>Next, we use a <b>generative model</b> to learn the accuracies of the labeling functions <i>without any labeled data</i>, and weight their outputs accordingly. We can even learn the <a href="https://arxiv.org/abs/1703.00854">structure of their correlations</a> automatically, avoiding e.g. double-counting problems.</li>

	<li>Finally, the end output is a set of <b><i>probabilistic</i></b> training labels, which we can use to train a powerful, flexible <b>discriminative model</b> that will generalize beyond the signal expressed in our LFs.</li>
</ul>
<p>This whole pipeline can be seen as providing a simple, robust, and model-agnostic approach to “programming” an ML model!</p>

<h2 id="injecting-domain-knowledge">A New Take on an Old Project: Injecting Domain Knowledge into AI</h2>

<div class="figure">
<img src="snorkel_img/gofai.png" width="75%" class="centered" alt="Injecting domain knowledge in AI"/>
</div>

<p>From a historical perspective, trying to “program” AI (i.e., inject domain knowledge) is nothing new&#8212;the change is that AI has never before been so powerful, nor such a difficult black box to interact with.</p>

<p>In the 1980’s, the focus in AI was on <i>expert systems</i>, which combined manually-curated <i>knowledge bases</i> of facts and rules from domain experts with <i>inference engines</i> to apply them. The port of input was simple: just enter new facts or rules into the knowledge base. However, this very simplicity also belied the brittleness of these systems. Entering rules and facts by hand was neither sufficiently exhaustive nor scalable enough to handle the long-tail, high-dimensional data (e.g. text, images, speech, etc.) present in many real world applications.</p>

<p>In the 1990’s, machine learning began to take off as the vehicle for integrating knowledge into AI systems, promising to do so automatically from labeled <i>training data</i> in powerful and flexible ways. Classical (non-representation-learning) machine learning approaches generally had two ports of domain expert input. First, these models were generally of much lower complexity than modern ones, meaning that smaller amounts of hand-labeled data could be used. Second, these models relied on hand-engineered features, which provided a direct way to encode, modify, and interact with the model’s base representation of the data. However, feature engineering was and is generally considered a task for ML experts, who often would spend entire PhDs crafting features for a particular task.</p>

<p>Enter deep learning models: due to their impressive ability to automatically learn representations across many domains and tasks, they have largely obviated the task of feature engineering. However, they are for the most part complete black boxes, with very few knobs for the average developer to play with other than labeling massive training sets. In many senses, they represent the opposite extreme of the brittle but easily-modifiable rules of old expert systems. This leads us back to our original question from a slightly different angle: How do we leverage our domain knowledge or task expertise to program modern deep learning models? Is there any way to combine the directness of the old rules-based expert systems with the flexibility and power of these modern machine learning methods?</p>

<h2 id="snorkel">Snorkel: Notes from a Year in the Field</h2>

<p>Snorkel is our ongoing attempt to build a system that combines the best of these worlds: the directness of writing code with the flexibility and power of modern machine learning models under the hood. In the Snorkel workflow, no labeled training data is used. Instead, users write <i>labeling functions (LFs)</i> which serve as the programming interface to generate weak supervision, which is then automatically modeled and used to train an end model, such as a DNN.</p>

<div class="figure">
<img src="snorkel_img/snorkel_system.png" width="100%" class="centered" alt="The Snorkel system workflow diagram"/>
</div>

<p>In our <a href="https://arxiv.org/abs/1711.10160">recent VLDB paper on Snorkel</a>, we find that in a variety of real-world applications, this new approach to interacting with modern machine learning models seems to work well! Some highlights include:</p>
<ul>
	<li>In a user study, conducted as part of a two-day <a href="http://mobilize.stanford.edu/events/snorkelworkshop2017/">workshop on Snorkel</a> hosted by the Mobilize center, we compared the productivity of teaching subject matter experts to use Snorkel, versus spending the equivalent time just hand-labeling data. We found that they were able to build models 2.8x faster and with 45.5% better predictive performance on average.</li>

	<li>On two real-world text relation extraction tasks--in collaboration with researchers from Stanford, the U.S. Dept. of Veterans Affairs, and the U.S. Food and Drug Administration--and four other benchmark text and image tasks, we found that Snorkel leads to an average 132% improvement over baseline techniques and comes within an average 3.6% of the predictive performance of large hand-curated training sets.</li>

	<li>We explored the novel tradeoff space of whether and at what complexity to model the user-provided labeling functions, leading to a rule-based optimizer for accelerating iterative development cycles.</li>
</ul>

<h2 id="next-steps">Next Steps</h2>

<p>Various efforts in our lab are already underway to extend the weak supervision interaction model envisioned in Snorkel to other modalities such as <a href="https://hazyresearch.github.io/snorkel/blog/fonduer.html">richly-formatted data</a>, modalities or settings where labeling functions are <a href="http://dawn.cs.stanford.edu/2017/09/14/coral/">difficult to directly write over the raw data</a>, and more! On the technical front, we’re interested in both extending the core data programming model at the heart of Snorkel, making it easier to specify labeling functions with higher-level interfaces such as <a href="https://hazyresearch.github.io/snorkel/blog/babble_labble.html">natural language</a>, as well as combining with other types of weak supervision such as <a href="https://hazyresearch.github.io/snorkel/blog/tanda.html">data augmentation</a>.</p>

<p>Snorkel is an active and ongoing project, so for code, tutorials, blog posts, and more, please check it out at <a href="snorkel.stanford.edu">snorkel.stanford.edu!</a></p>

<br />
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://snorkel-stanford-edu.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
</body>
</html>
